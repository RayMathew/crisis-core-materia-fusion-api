<!DOCTYPE html>
<html>
<head>
<title>README</title>

<style>
        .copy {
            max-width: 700px; font-family: sans-serif; margin: 0 auto; line-height: 1.5;
        }
        pre {
            background-color: #eee;
            padding: 1em;
            overflow: auto;
        }
        table {
            border-collapse: collapse;
            width: 100%;
        }
        table+table {
            margin-top: 2em;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 0.5em;
            vertical-align: top;
        }
        td:first-child {
            width: 170px;
        }
        td code {
            white-space: nowrap;
        }
        samp {
            color: rgb(110, 110, 110);
        }
</style>
</head>
<body>
<div class="copy">
<h1>README</h1>
<p>This codebase has been generated by <a href="https://autostrada.dev/">Autostrada</a>.</p>
<h2>Getting started</h2>
<p>Before running the application you will need a working PostgreSQL installation and a valid DSN (data source name) for connecting to the database.</p>
<p>Please open the <code>cmd/api/main.go</code> file and edit it to include your valid DSN as the default value.</p>
<pre>
cfg.db.dsn = env.GetString("DB_DSN", "YOUR DEFAULT DSN GOES HERE")
</pre>
<p>Note that this DSN must be in the format <code>user:pass@localhost:port/db</code> and <strong>not</strong> be prefixed with <code>postgres://</code>.</p>
<p>Make sure that you're in the root of the project directory, fetch the dependencies with <code>go mod tidy</code>, then run the application using <code>go run ./cmd/api</code>:</p>
<pre>
$ go mod tidy
$ go run ./cmd/api
</pre>
<p>If you make a request to the <code>GET /status</code> endpoint using <code>curl</code> you should get a response like this:</p>
<pre>
$ curl -i localhost:4444/status
<samp>HTTP/1.1 200 OK
Content-Type: application/json
Date: Mon, 09 May 2022 20:46:37 GMT
Content-Length: 23

{
    "Status": "OK",
}</samp></pre>
<p>You can also start the application with live reload support by using the <code>run</code> task in the <code>Makefile</code>:</p>
<pre>
$ make run
</pre>
<h2>Project structure</h2>
<p>Everything in the codebase is designed to be editable. Feel free to change and adapt it to meet your needs.</p>
<table>
<tbody>
<tr>
<td><strong><code>cmd/api</code></strong></td>
<td>Your application-specific code (handlers, routing, middleware, helpers) for dealing with HTTP requests and responses.</td>
</tr>
<tr>
<td><code>↳ cmd/api/errors.go</code></td>
<td>Contains helpers for managing and responding to error conditions.</td>
</tr>
<tr>
<td><code>↳ cmd/api/handlers.go</code></td>
<td>Contains your application HTTP handlers.</td>
</tr>
<tr>
<td><code>↳ cmd/api/helpers.go</code></td>
<td>Contains helper functions for common tasks.</td>
</tr>
<tr>
<td><code>↳ cmd/api/main.go</code></td>
<td>The entry point for the application. Responsible for parsing configuration settings initializing dependencies and running the server. Start here when you're looking through the code.</td>
</tr>
<tr>
<td><code>↳ cmd/api/middleware.go</code></td>
<td>Contains your application middleware.</td>
</tr>
<tr>
<td><code>↳ cmd/api/routes.go</code></td>
<td>Contains your application route mappings.</td>
</tr>
<tr>
<td><code>↳ cmd/api/server.go</code></td>
<td>Contains a helper functions for starting and gracefully shutting down the server.</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr>
<td><strong><code>internal</code></strong></td>
<td>Contains various helper packages used by the application.</td>
</tr>
<tr>
<td><code>↳ internal/database/</code></td>
<td>Contains your database-related code (setup, connection and queries).</td>
</tr>
<tr>
<td><code>↳ internal/env</code></td>
<td>Contains helper functions for reading configuration settings from environment variables.</td>
</tr>
<tr>
<td><code>↳ internal/request/</code></td>
<td>Contains helper functions for decoding JSON requests.</td>
</tr>
<tr>
<td><code>↳ internal/response/</code></td>
<td>Contains helper functions for sending JSON responses.</td>
</tr>
<tr>
<td><code>↳ internal/validator/</code></td>
<td>Contains validation helpers.</td>
</tr>
<tr>
<td><code>↳ internal/version/</code></td>
<td>Contains the application version number definition.</td>
</tr>
</tbody>
</table>
<h2>Configuration settings</h2>
<p>Configuration settings are managed via environment variables, with the environment variables read into your application in the <code>run()</code> function in the <code>main.go</code> file.</p>
<p>You can try this out by setting a <code>HTTP_PORT</code> environment variable to configure the network port that the server is listening on:</p>
<pre>
$ export HTTP_PORT="9999"
$ go run ./cmd/api
</pre>
<p>Feel free to adapt the <code>run()</code> function to parse additional environment variables and store their values in the <code>config</code> struct. The application uses helper functions in the <code>internal/env</code> package to parse environment variable values or return a default value if no matching environment variable is set. It includes <code>env.GetString()</code>, <code>env.GetInt()</code> and <code>env.GetBool()</code> functions for reading string, integer and bool values from environment variables. Again, you can add any additional helper functions that you need.</p>
<h2>Creating new handlers</h2>
<p>Handlers are defined as <code>http.HandlerFunc</code> methods on the <code>application</code> struct. They take the pattern:</p>
<pre>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    // Your handler logic...
}
</pre>
<p>Handlers are defined in the <code>cmd/api/handlers.go</code> file. For small applications, it's fine for all handlers to live in this file. For larger applications (10+ handlers) you may wish to break them out into separate files.</p>
<h2>Handler dependencies</h2>
<p>Any dependencies that your handlers have should be initialized in the <code>run()</code> function <code>cmd/api/main.go</code> and added to the <code>application</code> struct. All of your handlers, helpers and middleware that are defined as methods on <code>application</code> will then have access to them.</p>
<p>You can see an example of this in the <code>cmd/api/main.go</code> file where we initialize a new <code>logger</code> instance and add it to the <code>application</code> struct.</p>
<h2>Creating new routes</h2>
<p><a href="https://github.com/julienschmidt/httprouter">HttpRouter</a> is used for routing. Routes are defined in the <code>routes()</code> method in the <code>cmd/api/routes.go</code> file. For example:</p>
<pre>
func (app *application) routes() http.Handler {
    mux := httprouter.New()
    
    mux.HandlerFunc("GET", "/your/path", app.yourHandler)
    
    return mux
}
</pre>
<p>For more information about HttpRouter and example usage, please see the <a href="https://github.com/julienschmidt/httprouter">official documentation</a>.</p>
<h2>Adding middleware</h2>
<p>Middleware is defined as methods on the <code>application</code> struct in the <code>cmd/api/middleware.go</code> file. Feel free to add your own. They take the pattern:</p>
<pre>
func (app *application) yourMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Your middleware logic...
        next.ServeHTTP(w, r)
    })
}
</pre>
<p>You can then use this middleware by wrapping the router before returning it from the <code>routes()</code> method, like so:</p>
<pre>
func (app *application) routes() http.Handler {
    mux := httprouter.New()
    
    mux.HandlerFunc("GET", "/your/path", app.yourHandler)
    
    // Wrap the router with middleware.
    return app.yourMiddlware(app.yourOtherMiddleware(mux))
}
</pre>
<p>It's possible to use middleware on specific routes only:</p>
<pre>
func (app *application) routes() http.Handler {
    mux := httprouter.New()
    
    mux.HandlerFunc("GET", "/your/path", app.yourHandler)

    // Wrap this handler with route-specific middleware. Note that when 
    // wrapping handler functions with route-specific middleware that you
    // need to convert them to a http.Handler by using the http.HandlerFunc()
    // adapter. Like so: 
    mux.Handler("GET", "/your/other/path", app.yourOtherMiddleware(http.HandlerFunc(app.yourOtherHandler)))
    
    return app.yourMiddleware(mux)
}
</pre>
<h2>Sending JSON responses</h2>
<p>JSON responses and a specific HTTP status code can be sent using the <code>response.JSON()</code> function. The <code>data</code> parameter can be any JSON-marshalable type.</p>
<pre>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    data := map[string]string{"hello":  "world"}

    err := response.JSON(w, http.StatusOK, data)
    if err != nil {
        app.serverError(w, r, err)
    }
}
</pre>
<p>Specific HTTP headers can optionally be sent with the response too:</p>
<pre>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    data := map[string]string{"hello":  "world"}

    headers := make(http.Header)
    headers.Set("X-Server", "Go")

    err := response.JSONWithHeaders(w, http.StatusOK, data, headers)
    if err != nil {
        app.serverError(w, r, err)
    }
}
</pre>
<h2>Parsing JSON requests</h2>
<p>HTTP requests containing a JSON body can be decoded using the <code>request.DecodeJSON()</code> function. For example, to decode JSON into an <code>input</code> struct:</p>
<pre>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    var input struct {
        Name string `json:"Name"`
        Age  int    `json:"Age"`
    }

    err := request.DecodeJSON(w, r, &amp;input)
    if err != nil {
        app.badRequest(w, r, err)
        return
    }
    
    ...
}
</pre>
<p>Note: The target decode destination passed to <code>request.DecodeJSON()</code> (which in the example above is <code>&amp;input</code>) must be a non-nil pointer.</p>
<p>The <code>request.DecodeJSON()</code> function returns friendly, well-formed, error messages that are suitable to be sent directly to the client using the <code>app.badRequest()</code> helper.</p>
<p>There is also a <code>request.DecodeJSONStrict()</code> function, which works in the same way as <code>request.DecodeJSON()</code> except it will return an error if the request contains any JSON fields that do not match a name in the the target decode destination.</p>
<h2>Validating JSON requests</h2>
<p>The <code>internal/validator</code> package includes a simple (but powerful) <code>validator.Validator</code> type that you can use to carry out validation checks.</p>
<p>Extending the example above:</p>
<pre>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    var input struct {
        Name      string              `json:"Name"`
        Age       int                 `json:"Age"`
        Validator validator.Validator `json:"-"`
    }

    err := request.DecodeJSON(w, r, &amp;input)
    if err != nil {
        app.badRequest(w, r, err)
        return
    }

    input.Validator.CheckField(input.Name != "", "Name", "Name is required")
    input.Validator.CheckField(input.Age != 0, "Age", "Age is required")
    input.Validator.CheckField(input.Age &gt;= 21, "Age", "Age must be 21 or over")

    if input.Validator.HasErrors() {
        app.failedValidation(w, r, input.Validator)
        return
    }

    ...
}    
</pre>
<p>The <code>app.failedValidation()</code> helper will send a <code>422</code> status code along with any validation error messages. For the example above, the JSON response will look like this:</p>
<pre>
{
    "FieldErrors": {
        "Age": "Age must be 21 or over",
        "Name": "Name is required"
    }
}    
</pre>
<p>In the example above we use the <code>CheckField()</code> method to carry out validation checks for specific fields. You can also use the <code>Check()</code> method to carry out a validation check that is <em>not related to a specific field</em>. For example:</p>
<pre>
input.Validator.Check(input.Password == input.ConfirmPassword, "Passwords do not match")
</pre>
<p>The <code>validator.AddError()</code> and <code>validator.AddFieldError()</code> methods also let you add validation errors directly:</p>
<pre>
input.Validator.AddFieldError("Email", "This email address is already taken")
input.Validator.AddError("Passwords do not match")
</pre>
<p>The <code>internal/validator/helpers.go</code> file also contains some helper functions to simplify validations that are not simple comparison operations.</p>
<table>
<tbody>
<tr>
<td><code>NotBlank(value string)</code></td>
<td>Check that the value contains at least one non-whitespace character.</td>
</tr>
<tr>
<td><code>MinRunes(value string, n int)</code></td>
<td>Check that the value contains at least n runes.</td>
</tr>
<tr>
<td><code>MaxRunes(value string, n int)</code></td>
<td>Check that the value contains no more than n runes.</td>
</tr>
<tr>
<td><code>Between(value, min, max T)</code></td>
<td>Check that the value is between the min and max values inclusive.</td>
</tr>
<tr>
<td><code>Matches(value string, rx *regexp.Regexp)</code></td>
<td>Check that the value matches a specific regular expression.</td>
</tr>
<tr>
<td><code>In(value T, safelist ...T)</code></td>
<td>Check that a value is in a 'safelist' of specific values.</td>
</tr>
<tr>
<td><code>AllIn(values []T, safelist ...T)</code></td>
<td>Check that all values in a slice are in a 'safelist' of specific values.</td>
</tr>
<tr>
<td><code>NotIn(value T, blocklist ...T)</code></td>
<td>Check that the value is not in a 'blocklist' of specific values.</td>
</tr>
<tr>
<td><code>NoDuplicates(values []T)</code></td>
<td>Check that a slice does not contain any duplicate (repeated) values.</td>
</tr>
<tr>
<td><code>IsEmail(value string)</code></td>
<td>Check that the value has the formatting of a valid email address.</td>
</tr>
<tr>
<td><code>IsURL(value string)</code></td>
<td>Check that the value has the formatting of a valid URL.</td>
</tr>
</tbody>
</table>
<p>For example, to use the <code>Between</code> check your code would look similar to this:</p>
<pre>
input.Validator.CheckField(validator.Between(input.Age, 18, 30), "Age", "Age must between 18 and 30")
</pre>
<p>Feel free to add your own helper functions to the <code>internal/validator/helpers.go</code> file as necessary for your application.</p>
<h2>Working with the database</h2>
<p>This codebase is set up to use PostgreSQL with the <a href="https://github.com/lib/pq">lib/pq</a> driver. You can control which database you connect to using the <code>DB_DSN</code> environment variable to pass in a DSN, or by adapting the default value in <code>run()</code>.</p>
<p>The codebase is also configured to use <a href="https://github.com/jmoiron/sqlx">jmoiron/sqlx</a>, so you have access to the whole range of sqlx extensions as well as the standard library <code>Exec()</code>, <code>Query()</code> and <code>QueryRow()</code> methods .</p>
<p>The database is available to your handlers, middleware and helpers via the <code>application</code> struct. If you want, you can access the database and carry out queries directly. For example:</p>
<pre>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    ...

    _, err := app.db.Exec("INSERT INTO people (name, age) VALUES ($1, $2)", "Alice", 28)
    if err != nil {
        app.serverError(w, r, err)
        return
    }
    
    ...
}
</pre>
<p>Generally though, it's recommended to isolate your database logic in the <code>internal/database</code> package and extend the <code>DB</code> type to include your own methods. For example, you could create a <code>internal/database/people.go</code> file containing code like:</p>
<pre>
type Person struct {
    ID    int    `db:"id"`
    Name  string `db:"name"`
    Age   int    `db:"age"`
}

func (db *DB) NewPerson(name string, age int) error {
    _, err := db.Exec("INSERT INTO people (name, age) VALUES ($1, $2)", name, age)
    return err
}

func (db *DB) GetPerson(id int) (Person, error) {
    var person Person
    err := db.Get(&amp;person, "SELECT * FROM people WHERE id = $1", id)
    return person, err
}
</pre>
<p>And then call this from your handlers:</p>
<pre>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    ...

    err := app.db.NewPerson("Alice", 28)
    if err != nil {
        app.serverError(w, r, err)
        return
    }
    
    ...
}
</pre>
<h2>Logging</h2>
<p>Leveled logging is supported using the <a href="https://pkg.go.dev/log/slog">slog</a> and <a href="https://github.com/lmittmann/tint">tint</a> packages.</p>
<p>By default, a logger is initialized in the <code>main()</code> function. This logger writes all log messages above <code>Debug</code> level to <code>os.Stdout</code>.</p>
<pre>
logger := slog.New(tint.NewHandler(os.Stdout, &amp;tint.Options{Level: slog.LevelDebug}))
</pre>
<p>Feel free to customize this further as necessary.</p>
<p>Also note: Any messages that are automatically logged by the Go <code>http.Server</code> are output at the <code>Warn</code> level.</p>
<h2>Admin tasks</h2>
<p>The <code>Makefile</code> in the project root contains commands to easily run common admin tasks:</p>
<table>
<tbody>
<tr>
<td><code>$ make tidy</code></td>
<td>Format all code using <code>go fmt</code> and tidy the <code>go.mod</code> file.</td>
</tr>
<tr>
<td><code>$ make audit</code></td>
<td>Run <code>go vet</code>, <code>staticheck</code>, <code>govulncheck</code>, execute all tests and verify required modules.</td>
</tr>
<tr>
<td><code>$ make test</code></td>
<td>Run all tests.</td>
</tr>
<tr>
<td><code>$ make test/cover</code></td>
<td>Run all tests and outputs a coverage report in HTML format.</td>
</tr>
<tr>
<td><code>$ make build</code></td>
<td>Build a binary for the <code>cmd/api</code> application and store it in the <code>/tmp/bin</code> folder.</td>
</tr>
<tr>
<td><code>$ make run</code></td>
<td>Build and then run a binary for the <code>cmd/api</code> application.</td>
</tr>
<tr>
<td><code>$ make run/live</code></td>
<td>Build and then run a binary for the <code>cmd/api</code> application (uses live reloading).</td>
</tr>
</tbody>
</table>
<h2>Live reload</h2>
<p>When you use <code>make run/live</code> to run the application, the application will automatically be rebuilt and restarted whenever you make changes to any files with the following extensions:</p>
<pre>
.go
.tpl, .tmpl, .html
.css, .js, .sql
.jpeg, .jpg, .gif, .png, .bmp, .svg, .webp, .ico
</pre>
<p>Behind the scenes the live reload functionality uses the <a href="https://github.com/cosmtrek/air">cosmtrek/air</a> tool. You can configure how it works (including which file extensions and folders are watched for changes) by editing the <code>Makefile</code> file.</p>
<h2>Running background tasks</h2>
<p>A <code>backgroundTask()</code> helper is included in the <code>cmd/api/helpers.go</code> file. You can call this in your handlers, helpers and middleware to run any logic in a separate background goroutine. This useful for things like sending emails, or completing slow-running jobs.</p>
<p>You can call it like so:</p>
<pre>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    ...

    app.backgroundTask(r, func() error {
        // The logic you want to execute in a background task goes here.
        // It should return an error, or nil.
        err := doSomething()
        if err != nil {
            return err
        }

        return nil
    })
    
    ...
}
</pre>
<p>Using the <code>backgroundTask()</code> helper will automatically recover any panics in the background task logic, and when performing a graceful shutdown the application will wait for any background tasks to finish running before it exits.</p>
<h2>Application version</h2>
<p>The application version number is defined in a <code>Get()</code> function in the <code>internal/version/version.go</code> file. Feel free to change this as necessary.</p>
<pre>
package version

func Get() string {
    return "0.0.1"
}
</pre>
<h2>Changing the module path</h2>
<p>The module path is currently set to <code>github.com/RayMathew/crisis-core-materia-fusion-api</code>. If you want to change this please find and replace all instances of <code>github.com/RayMathew/crisis-core-materia-fusion-api</code> in the codebase with your own module path.</p>
</div>
<!--------------------------------------------------------------------
Admin
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Live reload
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
AutoHTTPS
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Module path
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Version
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Background tasks
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Logging
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Database
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Config
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Web:Templates
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Web:Static
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Web:Forms
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
JSON:Sending
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
JSON:Decoding
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Funcs
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Validator
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Middleware
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Routing
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Handlers
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Structure
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Start
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Migrations
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Basic Auth
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Sessions
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
SMTP
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Notifications
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
ACCOUNTS (WEB)
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
ACCOUNTS (API)
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Cookies
------------------------------------------------------------------ -->
</body>
</html>
